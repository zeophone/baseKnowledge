## 经常听到的面试题
#### 什么是三大范式
* 第一范式:确保每列的原子性；
* 第二范式:在第一范式的基础上更进一层,要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性；
	* 第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。
* 第三范式:在第二范式的基础上更进一层,目标是确保每列都和主键列直接相关,而不是间接相关。
	* 例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。
* BCFN:消除所有属性对主属性的传递依赖。
	* 3FN只消除非主属性对主属性的传递依赖，BCFN消除所有属性对主属性的传递依赖。
* 第四范式： 表中不能包含一个实体的两个或多个互相独立的多值因子。
	* 有这样一个用户联系方式表TELEPHONE(CUSTOMERID,PHONE,CELL)。 CUSTOMERID为用户ID,PHONE为用户的固定电话,CELL为用户的移动电话。 本来，这是一个非常简单的第3范式表。主键为CUSTOMERID，不存在传递依赖。但在某些情况下，这样的表还是不合理的。比如说，用户有两个固定电话，两个移动电话。也就是同一个主键id可能会存在两列数据。
* 第五范式： 表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。
	* 也就是说能分开的表一定要分开？那不是和第三范式一样了？
* @see:[http://baike.baidu.com/link?url=9BrdqLiP1eE5WTcJtGp3lixYYsyP04ui1XXc4DQdZMw8iETm4NmuAtdbmdGGp1nq0WoL76uelHTRjgiOF5eMC82vmiHQvs46zGU3ywjVzUGvho9YKYiQen0CiGefZ7O5EKamzgGZx3tJUnRD9Te67K](http://baike.baidu.com/link?url=9BrdqLiP1eE5WTcJtGp3lixYYsyP04ui1XXc4DQdZMw8iETm4NmuAtdbmdGGp1nq0WoL76uelHTRjgiOF5eMC82vmiHQvs46zGU3ywjVzUGvho9YKYiQen0CiGefZ7O5EKamzgGZx3tJUnRD9Te67K)

#### 左链接和右链接的区别

* 左链接： 左表全部行+右表匹配的行，如果左表中某行在右表中没有匹配的行，则显示NULL。
* 右链接:  先将右表数据全部列出，然后根据条件将左表列出，不存在以null表示。
* 内连接： 结果仅包含符合连接条件的两表中的行。基本和where条件一样。on中的and条件对左连接的左表没有效果。

	在使用left join时，on和where条件的区别如下：  
	1、on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。（实际上左连接中如果and语句是对左表进行过滤的，那么不管真假都不起任何作用。如果是对右表过滤的，那么左表所有记录都返回，右表筛选以后再与左表连接返回）  
	2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉，on后的条件用来生成左右表关联的临时表，where后的条件对临时表中的记录进行过滤。


* 全外连接：不管匹配不匹配，全部显示出来，左表在右边没有的显示NULL，右表在左边没有的显示NULL
* 交叉连接：返回左表中所有行与右表中所有行的组合，也称笛卡尔积。

@see:[http://blog.csdn.net/u012050154/article/details/52497395](http://blog.csdn.net/u012050154/article/details/52497395)

##数据库相关重要的知识点